'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var Metalsmith = _interopDefault(require('metalsmith'));
var asyncEach = _interopDefault(require('async.each'));
var match = _interopDefault(require('multimatch'));
var consolidate = _interopDefault(require('consolidate'));

var render = consolidate.handlebars.render;

function gracefulCopy(src, dest, ref) {
  if ( ref === void 0 ) ref = {};
  var data = ref.data;
  var cwd = ref.cwd; if ( cwd === void 0 ) cwd = process.cwd();
  var clean = ref.clean; if ( clean === void 0 ) clean = true;
  var skipInterpolation = ref.skipInterpolation;

  return new Promise(function (resolve, reject) {
    var source = path.resolve(cwd, src);
    Metalsmith(source) // eslint-disable-line new-cap
      .source('.')
      .use(template)
      .clean(clean)
      .destination(path.resolve(source, '../', dest))
      .build(function (err, files) {
        if (err) { return reject(err) }
        resolve(Object.keys(files));
      });
  })

  function template(files, metalsmith, done) {
    var keys = Object.keys(files);

    var matchedFiles = skipInterpolation && match(keys, skipInterpolation);

    asyncEach(keys, run, done);

    function run(file, done) {
      var str = files[file].contents.toString();
      // do not attempt to render files that do not have mustaches
      var noMustache = !/{{([^{}]+)}}/g.test(str);
      // skip interpolation by glob patterns like *.vue
      var shouldSkip = matchedFiles && (matchedFiles.indexOf(file) !== -1);

      if (shouldSkip || noMustache) {
        return done()
      }
      render(str, data, function (err, res) {
        if (err) {
          return done(err)
        }
        files[file].contents = new Buffer(res);
        done();
      });
    }
  }
}

module.exports = gracefulCopy;
